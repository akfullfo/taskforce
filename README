<meta name="google-site-verification" content="XFTpSbzCsAuilcZq1jBelrCMrP4-iVL6MB90v--0yoQ" />

Initially this supports python 2.7 on Unix derivatives.  It has specific support
for select.kqueue on MacOS and \*BSD and the inotifyx bindings for Linux inotify.
If neither of these facilities is available, `taskforce` operates in polling mode
which adds some latency and processing overhead but is functionally the same.

Commands to be run are defined in a configuration file in YAML format.  Let's go
straight to a quick example::

    {
        "tasks": {
            "sshd": {
                "control": "wait",
                "commands": { "start": [ "/usr/sbin/sshd", "-D" ] }
            },
            "ntpd": {
                "control": "wait",
                "requires": "sshd",
                "defines": { "conf": "/etc/ntp.conf" },
                "commands": { "start": [ "/usr/sbin/ntpd", "-c", "{conf}", "-n"] },
                "events": [
                    { "type": "self", "command": "stop" },
                    { "type": "file_change", "path": "{conf}", "command": "stop" }
                ]
            }
        }
    }

In this example, `taskforce` starts `sshd` and then starts `ntpd`.  `taskforce`
is set to wait on both programs and both programs are started so that they will
not detach themselves.  If either program exits, it will be restarted.

`ntpd` is run with a couple of extra features.  First, it defines a tag for the
configuration file name.  This is convenient for when the element is used in
multiple places.  It also adds two events.  The first fires if the executable
file changes, and the second fires if the configuration file changes.  The event
type ``self`` is shorthand for the equivalent ``file_change`` event.  In both cases,
the event will cause the task to be stopped.  As both tasks have the ``wait``
control, they will then be restarted.

Visit `<https://github.com/akfullfo/taskforce/>`_ for more information.
